/**
 * @module hex-window
 * Basic hexed window. Can contain multiple panes (well, WILL be able to) that
 * display the window.
 */

const { ipcMain, BrowserWindow, dialog } = require('electron'); // Module to create native browser window.
const debuglog = require('util').debuglog('hex-window');

const url = require('url');
const path = require('path');

/**
 * Internal ID for windows. Just keeps on counting up.
 */
let id = 0;

/**
 * Map of IDs to windows.
 */
var hexedWindows = {};

ipcMain.on('files-dropped', function(event, winId, files) {
  var win = hexedWindows[winId];
  if (win) {
    win.open(files);
  }
});

class HexedWindow {
  constructor() {
    this.window = new BrowserWindow({width: 800, height: 600});
    // I have a sneaking suspicion that the actual HTML file will be going away
    // and the entire document will be generated by code.
    this.window.loadURL(url.format({
      pathname: path.join(__dirname, '../src/hex-window.html'),
      protocol: 'file:',
      slashes: true
    }));
    this.window.hexed = this;
    this.id = id++;
    this._tabId = 0;
    hexedWindows[this.id] = this;
    this._loaded = false;
    this._pendingMessages = [];
    this._openFiles = [];
    this.window.webContents.on('will-navigate', (event) => {
      // Never load up new contents - prevents drag and drop from loading files
      // directly into the webview
      event.preventDefault();
    });
    this.window.webContents.on('did-finish-load', (event) => {
      this.window.webContents.send('set-id', this.id);
      this.window.emit('ready');
    });
    this.window.on('closed', (event) => {
      // Kill this window entirely as it's no longer valid
      debuglog("Window %s closed", this.id);
      delete hexedWindows[this.id];
    });
  }

  /**
   * Dev utility: reload all HTML for the window.
   */
  reload() {
    this.window.reloadIgnoringCache();
    if (this._openFiles.length > 0) {
      // Bind a new ready listener
      let files = this._openFiles;
      this._openFiles = [];
      this.window.once('ready', () => this.open(files));
    }
  }
  on(event, handler) {
    // Pass through to the window
    this.window.on(event, handler);
  }
  once(event, handler) {
    this.window.once(event, handler);
  }
  /**
   * Open the given file/files. If given a string, opens that single file. If
   * given an array, opens all files given.
   */
  open(path) {
    if (typeof path == 'string') {
      this.window.webContents.send('open-files', [ path ]);
      this._openFiles.push(path);
    } else if (typeof path == 'object' && typeof path.forEach == 'function') {
      let paths = [];
      path.forEach(function(p) {
        if (typeof p == 'string') {
          paths.push(p);
        }
      });
      if (paths.length > 0) {
        this.window.webContents.send('open-files', paths);
        Array.prototype.push.apply(this._openFiles, paths);
      }
    }
  }
  /**
   * Show the open file dialog, allowing the user to open a file.
   */
  showOpenDialog() {
    dialog.showOpenDialog(this.window, {
      treatPackageAsDirectory: true,
      multiSelections: true
    }, files => {
      if (files) {
        files.forEach(f => this.open(f));
      }
    });
  }
  closePane() {
    this.sendMenu('close-pane');
  }
  /**
   * Sends a notification that a menu option was chosen. These menu items have
   * no processing done on the "main process" side and are instead entirely
   * self-contained in the HTML side.
   */
  sendMenu(menu) {
    this.window.webContents.send('menu', menu);
  }
}

module.exports = HexedWindow;
