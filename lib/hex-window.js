/**
 * @module hex-window
 * Basic hexed window. Can contain multiple panes (well, WILL be able to) that
 * display the window.
 */

const { ipcMain, BrowserWindow, dialog } = require('electron'); // Module to create native browser window.
const debuglog = require('util').debuglog('hex-window');

const url = require('url');
const path = require('path');

/**
 * Internal ID for windows. Just keeps on counting up.
 */
let id = 0;

/**
 * Map of IDs to windows.
 */
var hexedWindows = {};

ipcMain.on('files-dropped', function(event, winId, files) {
  var win = hexedWindows[winId];
  if (win) {
    win.open(files);
  }
});

function HexedWindow() {
  this.window = new BrowserWindow({width: 800, height: 600});
  // I have a sneaking suspicion that the actual HTML file will be going away
  // and the entire document will be generated by code.
  this.window.loadURL(url.format({
    pathname: path.join(__dirname, '../src/hex-window.html'),
    protocol: 'file:',
    slashes: true
  }));
  this.window.hexed = this;
  this.id = id++;
  this._tabId = 0;
  hexedWindows[this.id] = this;
  this._loaded = false;
  this._pendingMessages = [];
  this._openFiles = [];
  this.window.webContents.on('will-navigate', function(event) {
    // Never load up new contents - prevents drag and drop from loading files
    // directly into the webview
    event.preventDefault();
  });
  this.window.webContents.on('did-finish-load', (function(me) {
    return function() {
      me.window.webContents.send('set-id', me.id);
      me.window.emit('ready');
    };
  })(this));
  this.window.on('closed', (function(me) {
    return function(event) {
      // Kill this window entirely as it's no longer valid
      debuglog("Window %s closed", me.id);
      delete hexedWindows[me.id];
    };
  })(this));
}

HexedWindow.prototype = {
  /**
   * Dev utility: reload all HTML for the window.
   */
  reload: function() {
    this.window.reloadIgnoringCache();
    if (this._openFiles.length > 0) {
      // Bind a new ready listener
      var me = this, files = this._openFiles;
      this._openFiles = [];
      this.window.once('ready', function() {
        me.open(files);
      });
    }
  },
  on: function(event, handler) {
    // Pass through to the window
    this.window.on(event, handler);
  },
  once: function(event, handler) {
    this.window.once(event, handler);
  },
  /**
   * Open the given file/files. If given a string, opens that single file. If
   * given an array, opens all files given.
   */
  open: function(path) {
    if (typeof path == 'string') {
      this.window.webContents.send('open-files', [ path ]);
      this._openFiles.push(path);
    } else if (typeof path == 'object' && typeof path.forEach == 'function') {
      var paths = [];
      path.forEach(function(p) {
        if (typeof p == 'string') {
          paths.push(p);
        }
      });
      if (paths.length > 0) {
        this.window.webContents.send('open-files', paths);
        Array.prototype.push.apply(this._openFiles, paths);
      }
    }
  },
  /**
   * Show the open file dialog, allowing the user to open a file.
   */
  showOpenDialog: function() {
    var me = this;
    dialog.showOpenDialog(this.window, {}, function(files) {
      if (files) {
        files.forEach(function(f) { me.open(f); });
      }
    });
  },
  closePane: function() {
    this.sendMenu('close-pane');
  },
  /**
   * Sends a notification that a menu option was chosen. These menu items have
   * no processing done on the "main process" side and are instead entirely
   * self-contained in the HTML side.
   */
  sendMenu: function(menu) {
    this.window.webContents.send('menu', menu);
  }
}

module.exports = HexedWindow;
